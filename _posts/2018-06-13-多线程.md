---
layout:     post
title:      多线程相关
subtitle:   乐观锁+悲观锁+CountDownLatch等等
date:       2018-06-13
author:     RX
header-img: img/post-bg-e2e-ux.jpg
catalog: true
tags:
    - 多线程
    - 乐观锁悲观锁
---

## 并发情况下 悲观锁 与乐观锁
###  首先介绍一些乐观锁与悲观锁:
　　悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。

　　乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，一般做法就是表增加一个字段"版本号"  每次更新的时候把查版本号+1  当别的线程同时更新时,比较版本号 如果不同 则不更新
  
#### 乐观锁实现:

> package com.renxin;

        /**
         * @Author: RenXin
         * @Date: Created in 2018/6/8
         * @Description:
         */

        import org.springframework.http.HttpRequest;

        import java.text.SimpleDateFormat;
        import java.util.Date;
        import java.util.concurrent.CountDownLatch;

        /**
         * 模拟用户的并发请求,检测用户乐观锁的性能问题
         */
        public class AccountWalletTest {
            final static SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

            static class AnalogUser extends Thread {
                String workerName;//模拟用户姓名
                String openId;   //用户id
                String openType;  //充值操作or消费操作
                String amount;  //金额
                CountDownLatch latch;

                public static void main(String[] args) {
                    CountDownLatch latch = new CountDownLatch(1);//模拟5人并发请求，用户钱包
                    for (int i = 0; i < 5; i++) {//模拟5个用户
                        AnalogUser analogUser = new AnalogUser("user" + i, "58899dcd-46b0-4b16-82df-bdfd0d953bfb", "1", "20", latch);
                        analogUser.start();
                    }
                    latch.countDown();//计数器減一  所有线程释放 并发访问。
                    System.out.println("所有模拟请求结束  at "+sdf.format(new Date()));
                }
                public AnalogUser(String workerName, String openId, String openType, String amount,
                                  CountDownLatch latch) {
                    super();
                    this.workerName = workerName;
                    this.openId = openId;
                    this.openType = openType;
                    this.amount = amount;
                    this.latch = latch;
                }
                public void run() {
                    // TODO Auto-generated method stub
                    try {
                        latch.await(); //一直阻塞当前线程，直到计时器的值为0
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    post();//发送post 请求
                }
                public void post(){
                    String result = "";
                    System.out.println("模拟用户： "+workerName+" 开始发送模拟请求  at "+sdf.format(new Date()));
                    result = HttpUtil.sendGet_text("http://localhost:8080/wallet2/getService2.action", "openId="+openId+"&openType="+openType+"&amount="+amount);
                    System.out.println("操作结果："+result);
                    System.out.println("模拟用户： "+workerName+" 模拟请求结束  at "+sdf.format(new Date()));

                }
            }
        }
